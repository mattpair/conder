// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`function with type return returns none 1`] = `[Error: Within function funk: Error: Function fails to return a value for all paths]`;

exports[`function with void returns type 1`] = `[Error: Within function funk: Error: Returning a variable doesn't make sense when the expected result is none]`;

exports[`getting all data - alternate syntax: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
get_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: String,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct simplesQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<String>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct simplesRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_simples;
            
                            // INTERPRETERS
                            
    async fn query_interpreter_simples(querySpec: &querySpec_simples, client: &Client) -> Result<Vec<simple>, Error> {
        
    // Gettting all simple
    let mut allsimple1 = client.query(\\"select * from simples \\", &[]).await?;

    

    let mut out = Vec::with_capacity(allsimple1.len());

    while let Some(row0) = allsimple1.pop() {
        let simpleEntityId2 = row0.get(\\"conduit_entity_id\\");
        
        out.push(simple {
            data: row0.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_simples(client: &Client, body: &simple) -> Result<(), Error> {
                client.query(\\"insert into simples(data) values ($1)\\", &[&body.data]).await?;
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPrevioussimples,
storeQuerysimples,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
simplesResult( Vec<simple>),
simplesQueryResult( Vec<simplesQueryResult>),
simplesRef(&'exec simplesRef),
simplesRefInstance( simplesRef),
ManysimplesRef(&'exec Vec<simplesRef>),
OptionalsimplesRef(&'exec Option<simplesRef>),
querySpec_simples(&'exec querySpec_simples),
querySpec_simplesInstance( querySpec_simples),
ManyquerySpec_simples(&'exec Vec<querySpec_simples>),
OptionalquerySpec_simples(&'exec Option<querySpec_simples>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPrevioussimples => {
                        match prev {
                            InterpreterType::simple(r) => {
                                match insert_simples(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerysimples => {
                        
                            let spec = querySpec_simples;
                            match query_interpreter_simples(&spec, &client).await {
                                Ok(out) => InterpreterType::simplesResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::string(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::simplesResult(data) => HttpResponse::Ok().json(data),
InterpreterType::simplesQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::simplesRef(data) => HttpResponse::Ok().json(data),
InterpreterType::simplesRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManysimplesRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalsimplesRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_simples(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_simplesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_simples(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_simples(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn get(data: web::Data<AppData>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.get_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/get\\", web::get().to(get))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    get_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"storeQuerysimples\\"
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`getting all data - alternate syntax: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE simples (
        data	text NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`if statements: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
echoWithIfs_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct Boolholder {
                value: bool,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            
                            // INTERPRETERS
                            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
BoolholderFieldAccess(BoolholderField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
Boolholder(&'exec Boolholder),
BoolholderInstance( Boolholder),
ManyBoolholder(&'exec Vec<Boolholder>),
OptionalBoolholder(&'exec Option<Boolholder>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::BoolholderFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::Boolholder(inside) => match *op_param {
                                    BoolholderField::BoolholdervalueFieldRef => InterpreterType::bool(&inside.value)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Boolholder(data) => HttpResponse::Ok().json(data),
InterpreterType::BoolholderInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyBoolholder(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalBoolholder(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn echoWithIfs(data: web::Data<AppData>, input: web::Json<Boolholder>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::Boolholder(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.echoWithIfs_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum BoolholderField {
                            BoolholdervalueFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/echoWithIfs\\", web::post().to(echoWithIfs))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    echoWithIfs_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"BoolholderFieldAccess\\",
    \\"data\\": \\"BoolholdervalueFieldRef\\"
  },
  {
    \\"kind\\": \\"negatePrev\\"
  },
  {
    \\"kind\\": \\"conditionalGoto\\",
    \\"data\\": 6
  },
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  },
  {
    \\"kind\\": \\"noop\\"
  },
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`if statements: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`inserting struct containing struct array: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
insert_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: String,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapper {
                innard: Vec<simple>,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStore_innardQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<String>
        }
        

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStoreQueryResult {
            conduit_entity_id: Option<i32>,
innard: Option<Vec<wrapStore_innardQueryResult>>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapStoreRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore_innard;
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore {
                innard: querySpec_wrapStore_innard
            }
            
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: &querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple6 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select right_ptr from rel_wrapStore_and_innard)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple6.len());

    while let Some(row5) = allsimple6.pop() {
        let simpleEntityId7 = row5.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row5.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId7)
        })
    }

    

                let mut entityIdTosimple4: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                while let Some(row8) = allsimple3.pop() {
                    entityIdTosimple4.insert(row8.conduit_entity_id.unwrap(), row8);
                }
                

                let mut lr9 = client.query(\\"select left_ptr, right_ptr from rel_wrapStore_and_innard\\", &[]).await?;
                let mut lrmap10: HashMap<i32, Vec<i32>> = HashMap::new();
                while let Some(lrrow11) = lr9.pop() {
                    let l12 = lrrow11.get(\\"left_ptr\\");
                    lrmap10.entry(l12)
                        .and_modify(|e13| { e13.push(lrrow11.get(\\"right_ptr\\")) })
                        .or_insert(vec![lrrow11.get(\\"right_ptr\\")]);
                }

                

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                // Extracting simples
                let empty17 = Vec::with_capacity(0);
                let entriessimple14 = match lrmap10.remove(&wrapperEntityId2) {
                    Some(ptrs) => ptrs,
                    None => empty17
                };

                let mut instancessimple15: Vec<simple> = Vec::with_capacity(entriessimple14.len());

                for child16 in entriessimple14 {
                    match entityIdTosimple4.remove(&child16) {
                        Some(real) => instancessimple15.push(real),
                        None => panic!(\\"could not find expected simple\\")
                    };
                }
                
        out.push(wrapper {
            innard: instancessimple15,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_wrapStore(client: &Client, body: &wrapper) -> Result<(), Error> {
                
                let mut vec_ret0: Vec<i32> = Vec::new();
                for row1 in &body.innard {
                    let ret0 = client.query(\\"insert into wrapStore_innard(data) values ($1) RETURNING conduit_entity_id\\", &[&row1.data]).await?;
                    vec_ret0.push(ret0[0].get(0));
                }
                
let ret3 = client.query(\\"insert into wrapStore default values RETURNING conduit_entity_id\\", &[]).await?;


                let ent4: i32 = ret3[0].get(0);
                while let Some(child_id) = vec_ret0.pop() {
                    client.query(\\"insert into rel_wrapStore_and_innard(left_ptr, right_ptr) values ($1, $2)\\", &[&ent4, &child_id]).await?;
                }
                    
                
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPreviouswrapStore,
storeQuerywrapStore,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField),
wrapperFieldAccess(wrapperField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
wrapper(&'exec wrapper),
wrapperInstance( wrapper),
Manywrapper(&'exec Vec<wrapper>),
Optionalwrapper(&'exec Option<wrapper>),
wrapStoreResult( Vec<wrapper>),
wrapStoreQueryResult( Vec<wrapStoreQueryResult>),
wrapStoreRef(&'exec wrapStoreRef),
wrapStoreRefInstance( wrapStoreRef),
ManywrapStoreRef(&'exec Vec<wrapStoreRef>),
OptionalwrapStoreRef(&'exec Option<wrapStoreRef>),
querySpec_wrapStore_innard(&'exec querySpec_wrapStore_innard),
querySpec_wrapStore_innardInstance( querySpec_wrapStore_innard),
ManyquerySpec_wrapStore_innard(&'exec Vec<querySpec_wrapStore_innard>),
OptionalquerySpec_wrapStore_innard(&'exec Option<querySpec_wrapStore_innard>),
querySpec_wrapStore(&'exec querySpec_wrapStore),
querySpec_wrapStoreInstance( querySpec_wrapStore),
ManyquerySpec_wrapStore(&'exec Vec<querySpec_wrapStore>),
OptionalquerySpec_wrapStore(&'exec Option<querySpec_wrapStore>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPreviouswrapStore => {
                        match prev {
                            InterpreterType::wrapper(r) => {
                                match insert_wrapStore(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerywrapStore => {
                        
                            let spec = querySpec_wrapStore {
            innard: querySpec_wrapStore_innard
        };
                            match query_interpreter_wrapStore(&spec, &client).await {
                                Ok(out) => InterpreterType::wrapStoreResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::string(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    },
Op::wrapperFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::wrapper(inside) => match *op_param {
                                    wrapperField::wrapperinnardFieldRef => InterpreterType::Manysimple(&inside.innard)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapperInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manywrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalwrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManywrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalwrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innardInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStoreInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn insert(data: web::Data<AppData>, input: web::Json<wrapper>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::wrapper(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.insert_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        

                        #[derive(Serialize, Deserialize, Clone)]
                        enum wrapperField {
                            wrapperinnardFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/insert\\", web::post().to(insert))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    insert_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"storeInsertPreviouswrapStore\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`inserting struct containing struct array: main files 2`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
insert_executable: Vec<Op>,get_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: String,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapper {
                innard: Vec<simple>,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStore_innardQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<String>
        }
        

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStoreQueryResult {
            conduit_entity_id: Option<i32>,
innard: Option<Vec<wrapStore_innardQueryResult>>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapStoreRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore_innard;
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore {
                innard: querySpec_wrapStore_innard
            }
            
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: &querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple6 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select right_ptr from rel_wrapStore_and_innard)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple6.len());

    while let Some(row5) = allsimple6.pop() {
        let simpleEntityId7 = row5.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row5.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId7)
        })
    }

    

                let mut entityIdTosimple4: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                while let Some(row8) = allsimple3.pop() {
                    entityIdTosimple4.insert(row8.conduit_entity_id.unwrap(), row8);
                }
                

                let mut lr9 = client.query(\\"select left_ptr, right_ptr from rel_wrapStore_and_innard\\", &[]).await?;
                let mut lrmap10: HashMap<i32, Vec<i32>> = HashMap::new();
                while let Some(lrrow11) = lr9.pop() {
                    let l12 = lrrow11.get(\\"left_ptr\\");
                    lrmap10.entry(l12)
                        .and_modify(|e13| { e13.push(lrrow11.get(\\"right_ptr\\")) })
                        .or_insert(vec![lrrow11.get(\\"right_ptr\\")]);
                }

                

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                // Extracting simples
                let empty17 = Vec::with_capacity(0);
                let entriessimple14 = match lrmap10.remove(&wrapperEntityId2) {
                    Some(ptrs) => ptrs,
                    None => empty17
                };

                let mut instancessimple15: Vec<simple> = Vec::with_capacity(entriessimple14.len());

                for child16 in entriessimple14 {
                    match entityIdTosimple4.remove(&child16) {
                        Some(real) => instancessimple15.push(real),
                        None => panic!(\\"could not find expected simple\\")
                    };
                }
                
        out.push(wrapper {
            innard: instancessimple15,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_wrapStore(client: &Client, body: &wrapper) -> Result<(), Error> {
                
                let mut vec_ret0: Vec<i32> = Vec::new();
                for row1 in &body.innard {
                    let ret0 = client.query(\\"insert into wrapStore_innard(data) values ($1) RETURNING conduit_entity_id\\", &[&row1.data]).await?;
                    vec_ret0.push(ret0[0].get(0));
                }
                
let ret3 = client.query(\\"insert into wrapStore default values RETURNING conduit_entity_id\\", &[]).await?;


                let ent4: i32 = ret3[0].get(0);
                while let Some(child_id) = vec_ret0.pop() {
                    client.query(\\"insert into rel_wrapStore_and_innard(left_ptr, right_ptr) values ($1, $2)\\", &[&ent4, &child_id]).await?;
                }
                    
                
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPreviouswrapStore,
storeQuerywrapStore,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField),
wrapperFieldAccess(wrapperField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
wrapper(&'exec wrapper),
wrapperInstance( wrapper),
Manywrapper(&'exec Vec<wrapper>),
Optionalwrapper(&'exec Option<wrapper>),
wrapStoreResult( Vec<wrapper>),
wrapStoreQueryResult( Vec<wrapStoreQueryResult>),
wrapStoreRef(&'exec wrapStoreRef),
wrapStoreRefInstance( wrapStoreRef),
ManywrapStoreRef(&'exec Vec<wrapStoreRef>),
OptionalwrapStoreRef(&'exec Option<wrapStoreRef>),
querySpec_wrapStore_innard(&'exec querySpec_wrapStore_innard),
querySpec_wrapStore_innardInstance( querySpec_wrapStore_innard),
ManyquerySpec_wrapStore_innard(&'exec Vec<querySpec_wrapStore_innard>),
OptionalquerySpec_wrapStore_innard(&'exec Option<querySpec_wrapStore_innard>),
querySpec_wrapStore(&'exec querySpec_wrapStore),
querySpec_wrapStoreInstance( querySpec_wrapStore),
ManyquerySpec_wrapStore(&'exec Vec<querySpec_wrapStore>),
OptionalquerySpec_wrapStore(&'exec Option<querySpec_wrapStore>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPreviouswrapStore => {
                        match prev {
                            InterpreterType::wrapper(r) => {
                                match insert_wrapStore(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerywrapStore => {
                        
                            let spec = querySpec_wrapStore {
            innard: querySpec_wrapStore_innard
        };
                            match query_interpreter_wrapStore(&spec, &client).await {
                                Ok(out) => InterpreterType::wrapStoreResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::string(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    },
Op::wrapperFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::wrapper(inside) => match *op_param {
                                    wrapperField::wrapperinnardFieldRef => InterpreterType::Manysimple(&inside.innard)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapperInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manywrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalwrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManywrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalwrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innardInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStoreInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn insert(data: web::Data<AppData>, input: web::Json<wrapper>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::wrapper(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.insert_executable).await;
        }
        


        
        async fn get(data: web::Data<AppData>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.get_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        

                        #[derive(Serialize, Deserialize, Clone)]
                        enum wrapperField {
                            wrapperinnardFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/insert\\", web::post().to(insert))
.route(\\"/get\\", web::get().to(get))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    insert_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"storeInsertPreviouswrapStore\\"
  }
]\\"#####).unwrap(),
get_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"storeQuerywrapStore\\"
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`inserting struct containing struct array: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                CREATE TABLE rel_wrapStore_and_innard (
                    left_ptr INT,
                    right_ptr INT,
                    FOREIGN KEY(right_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
                    FOREIGN KEY(left_ptr) REFERENCES wrapStore(conduit_entity_id)
                );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`inserting struct containing struct array: postgres files 2`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                CREATE TABLE rel_wrapStore_and_innard (
                    left_ptr INT,
                    right_ptr INT,
                    FOREIGN KEY(right_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
                    FOREIGN KEY(left_ptr) REFERENCES wrapStore(conduit_entity_id)
                );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`nested if statements: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
echoWithIfs_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct Boolholder {
                value: bool,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            
                            // INTERPRETERS
                            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
BoolholderFieldAccess(BoolholderField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
Boolholder(&'exec Boolholder),
BoolholderInstance( Boolholder),
ManyBoolholder(&'exec Vec<Boolholder>),
OptionalBoolholder(&'exec Option<Boolholder>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::BoolholderFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::Boolholder(inside) => match *op_param {
                                    BoolholderField::BoolholdervalueFieldRef => InterpreterType::bool(&inside.value)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Boolholder(data) => HttpResponse::Ok().json(data),
InterpreterType::BoolholderInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyBoolholder(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalBoolholder(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn echoWithIfs(data: web::Data<AppData>, input: web::Json<Boolholder>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::Boolholder(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.echoWithIfs_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum BoolholderField {
                            BoolholdervalueFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/echoWithIfs\\", web::post().to(echoWithIfs))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    echoWithIfs_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"BoolholderFieldAccess\\",
    \\"data\\": \\"BoolholdervalueFieldRef\\"
  },
  {
    \\"kind\\": \\"negatePrev\\"
  },
  {
    \\"kind\\": \\"conditionalGoto\\",
    \\"data\\": 11
  },
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"BoolholderFieldAccess\\",
    \\"data\\": \\"BoolholdervalueFieldRef\\"
  },
  {
    \\"kind\\": \\"negatePrev\\"
  },
  {
    \\"kind\\": \\"conditionalGoto\\",
    \\"data\\": 10
  },
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  },
  {
    \\"kind\\": \\"noop\\"
  },
  {
    \\"kind\\": \\"noop\\"
  },
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`nested if statements: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`not returning anything - if  1`] = `[Error: Within function echosBool: Error: Types are not equal]`;

exports[`not returning anything 1`] = `[Error: Within function echosSingleton: Error: Function fails to return a value for all paths]`;

exports[`returning wrong thing  1`] = `[Error: Within function echosBool: Error: Types are not equal]`;

exports[`simple struct: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
insert_executable: Vec<Op>,get_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: f64,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct simpleStoreQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<f64>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct simpleStoreRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_simpleStore;
            
                            // INTERPRETERS
                            
    async fn query_interpreter_simpleStore(querySpec: &querySpec_simpleStore, client: &Client) -> Result<Vec<simple>, Error> {
        
    // Gettting all simple
    let mut allsimple1 = client.query(\\"select * from simpleStore \\", &[]).await?;

    

    let mut out = Vec::with_capacity(allsimple1.len());

    while let Some(row0) = allsimple1.pop() {
        let simpleEntityId2 = row0.get(\\"conduit_entity_id\\");
        
        out.push(simple {
            data: row0.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_simpleStore(client: &Client, body: &simple) -> Result<(), Error> {
                client.query(\\"insert into simpleStore(data) values ($1)\\", &[&body.data]).await?;
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPrevioussimpleStore,
storeQuerysimpleStore,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
simpleStoreResult( Vec<simple>),
simpleStoreQueryResult( Vec<simpleStoreQueryResult>),
simpleStoreRef(&'exec simpleStoreRef),
simpleStoreRefInstance( simpleStoreRef),
ManysimpleStoreRef(&'exec Vec<simpleStoreRef>),
OptionalsimpleStoreRef(&'exec Option<simpleStoreRef>),
querySpec_simpleStore(&'exec querySpec_simpleStore),
querySpec_simpleStoreInstance( querySpec_simpleStore),
ManyquerySpec_simpleStore(&'exec Vec<querySpec_simpleStore>),
OptionalquerySpec_simpleStore(&'exec Option<querySpec_simpleStore>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPrevioussimpleStore => {
                        match prev {
                            InterpreterType::simple(r) => {
                                match insert_simpleStore(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerysimpleStore => {
                        
                            let spec = querySpec_simpleStore;
                            match query_interpreter_simpleStore(&spec, &client).await {
                                Ok(out) => InterpreterType::simpleStoreResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::double(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleStoreResult(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleStoreQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleStoreRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManysimpleStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalsimpleStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_simpleStore(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_simpleStoreInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_simpleStore(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_simpleStore(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn insert(data: web::Data<AppData>, input: web::Json<simple>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::simple(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.insert_executable).await;
        }
        


        
        async fn get(data: web::Data<AppData>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.get_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/insert\\", web::post().to(insert))
.route(\\"/get\\", web::get().to(get))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    insert_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"storeInsertPrevioussimpleStore\\"
  }
]\\"#####).unwrap(),
get_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"storeQuerysimpleStore\\"
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`simple struct: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE simpleStore (
        data	double precision NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`struct containing struct containing primitive array: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
insert_executable: Vec<Op>,get_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: Vec<String>,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapper {
                innard: simple,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStore_innardQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<Vec<String>>
        }
        

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStoreQueryResult {
            conduit_entity_id: Option<i32>,
innard: Option<wrapStore_innardQueryResult>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapStoreRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore_innard;
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore {
                innard: querySpec_wrapStore_innard
            }
            
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: &querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple5 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select innard_ptr from wrapStore)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple5.len());

    while let Some(row4) = allsimple5.pop() {
        let simpleEntityId6 = row4.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row4.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId6)
        })
    }

    

                    let mut entityIdTosimple7: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                    while let Some(row8) = allsimple3.pop() {
                        entityIdTosimple7.insert(row8.conduit_entity_id.unwrap(), row8);
                    }
                    

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                    // Extracting simple
                    let extractedsimple9 = match entityIdTosimple7.remove(&row0.get(\\"innard_ptr\\")) {
                        Some(t) => t,
                        None => panic!(\\"did not get an expected innard_ptr\\")
                    };
                    
        out.push(wrapper {
            innard: extractedsimple9,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_wrapStore(client: &Client, body: &wrapper) -> Result<(), Error> {
                let ret0 = client.query(\\"insert into wrapStore_innard(data) values ($1) RETURNING conduit_entity_id\\", &[&body.innard.data]).await?;
let entId1: i32 = ret0[0].get(0);
client.query(\\"insert into wrapStore(innard_ptr) values ($1)\\", &[ &entId1]).await?;
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPreviouswrapStore,
storeQuerywrapStore,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField),
wrapperFieldAccess(wrapperField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
wrapper(&'exec wrapper),
wrapperInstance( wrapper),
Manywrapper(&'exec Vec<wrapper>),
Optionalwrapper(&'exec Option<wrapper>),
wrapStoreResult( Vec<wrapper>),
wrapStoreQueryResult( Vec<wrapStoreQueryResult>),
wrapStoreRef(&'exec wrapStoreRef),
wrapStoreRefInstance( wrapStoreRef),
ManywrapStoreRef(&'exec Vec<wrapStoreRef>),
OptionalwrapStoreRef(&'exec Option<wrapStoreRef>),
querySpec_wrapStore_innard(&'exec querySpec_wrapStore_innard),
querySpec_wrapStore_innardInstance( querySpec_wrapStore_innard),
ManyquerySpec_wrapStore_innard(&'exec Vec<querySpec_wrapStore_innard>),
OptionalquerySpec_wrapStore_innard(&'exec Option<querySpec_wrapStore_innard>),
querySpec_wrapStore(&'exec querySpec_wrapStore),
querySpec_wrapStoreInstance( querySpec_wrapStore),
ManyquerySpec_wrapStore(&'exec Vec<querySpec_wrapStore>),
OptionalquerySpec_wrapStore(&'exec Option<querySpec_wrapStore>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPreviouswrapStore => {
                        match prev {
                            InterpreterType::wrapper(r) => {
                                match insert_wrapStore(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerywrapStore => {
                        
                            let spec = querySpec_wrapStore {
            innard: querySpec_wrapStore_innard
        };
                            match query_interpreter_wrapStore(&spec, &client).await {
                                Ok(out) => InterpreterType::wrapStoreResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::Manystring(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    },
Op::wrapperFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::wrapper(inside) => match *op_param {
                                    wrapperField::wrapperinnardFieldRef => InterpreterType::simple(&inside.innard)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapperInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manywrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalwrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManywrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalwrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innardInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStoreInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn insert(data: web::Data<AppData>, input: web::Json<wrapper>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::wrapper(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.insert_executable).await;
        }
        


        
        async fn get(data: web::Data<AppData>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.get_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        

                        #[derive(Serialize, Deserialize, Clone)]
                        enum wrapperField {
                            wrapperinnardFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/insert\\", web::post().to(insert))
.route(\\"/get\\", web::get().to(get))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    insert_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"storeInsertPreviouswrapStore\\"
  }
]\\"#####).unwrap(),
get_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"storeQuerywrapStore\\"
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`struct containing struct containing primitive array: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text[],
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        innard_ptr	INT,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
FOREIGN KEY(innard_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`struct containing struct: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            #![allow(unused_variables)]
                            #![allow(dead_code)]
                            #![allow(unused_imports)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use actix_rt::System;
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                            use awc;
                            use std::borrow::Borrow;
                            use bytes::Bytes;
                
                
                            struct AppData {
                                client: Client,
insert_executable: Vec<Op>,get_executable: Vec<Op>
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
            #[derive(Serialize, Deserialize, Clone)]
            struct simple {
                data: bool,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapper {
                innard: simple,
#[serde(skip)]
conduit_entity_id: Option<i32>
            }
            

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStore_innardQueryResult {
            conduit_entity_id: Option<i32>,
data: Option<bool>
        }
        

        #[derive(Serialize, Deserialize, Clone)]
        struct wrapStoreQueryResult {
            conduit_entity_id: Option<i32>,
innard: Option<wrapStore_innardQueryResult>
        }
        

            #[derive(Serialize, Deserialize, Clone)]
            struct wrapStoreRef {
                conduit_entity_id: i32
            }
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore_innard;
            

            #[derive(Serialize, Deserialize, Clone)]
            struct querySpec_wrapStore {
                innard: querySpec_wrapStore_innard
            }
            
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: &querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple5 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select innard_ptr from wrapStore)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple5.len());

    while let Some(row4) = allsimple5.pop() {
        let simpleEntityId6 = row4.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row4.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId6)
        })
    }

    

                    let mut entityIdTosimple7: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                    while let Some(row8) = allsimple3.pop() {
                        entityIdTosimple7.insert(row8.conduit_entity_id.unwrap(), row8);
                    }
                    

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                    // Extracting simple
                    let extractedsimple9 = match entityIdTosimple7.remove(&row0.get(\\"innard_ptr\\")) {
                        Some(t) => t,
                        None => panic!(\\"did not get an expected innard_ptr\\")
                    };
                    
        out.push(wrapper {
            innard: extractedsimple9,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    

            async fn insert_wrapStore(client: &Client, body: &wrapper) -> Result<(), Error> {
                let ret0 = client.query(\\"insert into wrapStore_innard(data) values ($1) RETURNING conduit_entity_id\\", &[&body.innard.data]).await?;
let entId1: i32 = ret0[0].get(0);
client.query(\\"insert into wrapStore(innard_ptr) values ($1)\\", &[ &entId1]).await?;
                return Ok(());
            }
            
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Op {
        pushPreviousOnCallStack,
negatePrev,
noop,
dropVariables(usize),
storeInsertPreviouswrapStore,
storeQuerywrapStore,
gotoOp(usize),
conditionalGoto(usize),
returnVariable(usize),
returnPrevious,
savePrevious,
echoVariable(usize),
simpleFieldAccess(simpleField),
wrapperFieldAccess(wrapperField)
    }

    #[derive(Serialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum InterpreterType<'exec> {
        None,
Err(String),
double(&'exec f64),
doubleInstance( f64),
Manydouble(&'exec Vec<f64>),
Optionaldouble(&'exec Option<f64>),
float(&'exec f32),
floatInstance( f32),
Manyfloat(&'exec Vec<f32>),
Optionalfloat(&'exec Option<f32>),
int32(&'exec i32),
int32Instance( i32),
Manyint32(&'exec Vec<i32>),
Optionalint32(&'exec Option<i32>),
int64(&'exec i64),
int64Instance( i64),
Manyint64(&'exec Vec<i64>),
Optionalint64(&'exec Option<i64>),
uint32(&'exec i32),
uint32Instance( i32),
Manyuint32(&'exec Vec<i32>),
Optionaluint32(&'exec Option<i32>),
uint64(&'exec i64),
uint64Instance( i64),
Manyuint64(&'exec Vec<i64>),
Optionaluint64(&'exec Option<i64>),
bool(&'exec bool),
boolInstance( bool),
Manybool(&'exec Vec<bool>),
Optionalbool(&'exec Option<bool>),
string(&'exec String),
stringInstance( String),
Manystring(&'exec Vec<String>),
Optionalstring(&'exec Option<String>),
bytes(&'exec Vec<u8>),
bytesInstance( Vec<u8>),
Manybytes(&'exec Vec<Vec<u8>>),
Optionalbytes(&'exec Option<Vec<u8>>),
simple(&'exec simple),
simpleInstance( simple),
Manysimple(&'exec Vec<simple>),
Optionalsimple(&'exec Option<simple>),
wrapper(&'exec wrapper),
wrapperInstance( wrapper),
Manywrapper(&'exec Vec<wrapper>),
Optionalwrapper(&'exec Option<wrapper>),
wrapStoreResult( Vec<wrapper>),
wrapStoreQueryResult( Vec<wrapStoreQueryResult>),
wrapStoreRef(&'exec wrapStoreRef),
wrapStoreRefInstance( wrapStoreRef),
ManywrapStoreRef(&'exec Vec<wrapStoreRef>),
OptionalwrapStoreRef(&'exec Option<wrapStoreRef>),
querySpec_wrapStore_innard(&'exec querySpec_wrapStore_innard),
querySpec_wrapStore_innardInstance( querySpec_wrapStore_innard),
ManyquerySpec_wrapStore_innard(&'exec Vec<querySpec_wrapStore_innard>),
OptionalquerySpec_wrapStore_innard(&'exec Option<querySpec_wrapStore_innard>),
querySpec_wrapStore(&'exec querySpec_wrapStore),
querySpec_wrapStoreInstance( querySpec_wrapStore),
ManyquerySpec_wrapStore(&'exec Vec<querySpec_wrapStore>),
OptionalquerySpec_wrapStore(&'exec Option<querySpec_wrapStore>)
    }

    
    async fn conduit_byte_code_interpreter_internal<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> InterpreterType<'a> {
        let mut prev: InterpreterType<'a>= InterpreterType::None;
        let mut callstack: Vec<InterpreterType<'a>> = Vec::new();
        
        let mut next_op_index = 0;
        while next_op_index < ops.len() {

            prev = match &ops[next_op_index] {
                Op::pushPreviousOnCallStack => {
                        callstack.push(prev); InterpreterType::None
                    },
Op::negatePrev => {
                        match prev {
                        InterpreterType::bool(b) => InterpreterType::boolInstance(!b),
                        InterpreterType::boolInstance(b) => InterpreterType::boolInstance(!b),
                        _ => InterpreterType::Err(\\"Negating a non boolean value\\".to_string())
                    }
                    },
Op::noop => {
                        InterpreterType::None
                    },
Op::dropVariables(op_param) => {
                        state.truncate(state.len() - *op_param); InterpreterType::None
                    },
Op::storeInsertPreviouswrapStore => {
                        match prev {
                            InterpreterType::wrapper(r) => {
                                match insert_wrapStore(&client, &r).await {
                                    Ok(()) => InterpreterType::None,
                                    Err(err) => InterpreterType::Err(err.to_string())
                                }
                            },
                            _ => InterpreterType::Err(\\"Invalid insertion type\\".to_string())
                        }
                    },
Op::storeQuerywrapStore => {
                        
                            let spec = querySpec_wrapStore {
            innard: querySpec_wrapStore_innard
        };
                            match query_interpreter_wrapStore(&spec, &client).await {
                                Ok(out) => InterpreterType::wrapStoreResult(out),
                                Err(err) => InterpreterType::Err(err.to_string())
                            }
                        
                    },
Op::gotoOp(op_param) => {
                        
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                    },
Op::conditionalGoto(op_param) => {
                        
                    match prev {
                        InterpreterType::bool(b) => {
                            if *b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        InterpreterType::boolInstance(b) => {
                            if b {
                                
            if *op_param >= ops.len() {
                panic!(\\"Setting op index out of bounds\\");
            }
            next_op_index = *op_param - 1;
            InterpreterType::None
            
                            } else {
                                InterpreterType::None
                            }
                        },
                        _ => InterpreterType::Err(\\"Cannot evaluate variable as boolean\\".to_string())
                    }
                    
                    },
Op::returnVariable(op_param) => {
                         return state.swap_remove(*op_param)
                    },
Op::returnPrevious => {
                        return prev
                    },
Op::savePrevious => {
                        state.push(prev); InterpreterType::None
                    },
Op::echoVariable(op_param) => {
                        match state.get(*op_param) {
                        Some(d) => d.clone(),
                        None => InterpreterType::Err(\\"Echoing variable that does not exist\\".to_string())
                    }
                    },
Op::simpleFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::simple(inside) => match *op_param {
                                    simpleField::simpledataFieldRef => InterpreterType::bool(&inside.data)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    },
Op::wrapperFieldAccess(op_param) => {
                        
                            match prev {
                                InterpreterType::wrapper(inside) => match *op_param {
                                    wrapperField::wrapperinnardFieldRef => InterpreterType::simple(&inside.innard)

                                },
                                _ => InterpreterType::Err(\\"Attempting to reference a field that doesn't exist on current type\\".to_string())
                            }
                                
                            
                    }
            };
            next_op_index += 1;
        
            match prev {
                InterpreterType::Err(_) => return prev,
                _ => {}  
            };
        }
        
            
        
        return InterpreterType::None;
    }

    async fn conduit_byte_code_interpreter<'a>(client: &Client, state: &'a mut Vec<InterpreterType<'a>>, ops: &Vec<Op>) -> impl Responder {
        return match conduit_byte_code_interpreter_internal(client, state, ops).await {
            InterpreterType::None => HttpResponse::Ok().finish(),
InterpreterType::Err(e) => {
                println!(\\"Error: {}\\", e);
                HttpResponse::BadRequest().finish()
            },
InterpreterType::double(data) => HttpResponse::Ok().json(data),
InterpreterType::doubleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manydouble(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaldouble(data) => HttpResponse::Ok().json(data),
InterpreterType::float(data) => HttpResponse::Ok().json(data),
InterpreterType::floatInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalfloat(data) => HttpResponse::Ok().json(data),
InterpreterType::int32(data) => HttpResponse::Ok().json(data),
InterpreterType::int32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint32(data) => HttpResponse::Ok().json(data),
InterpreterType::int64(data) => HttpResponse::Ok().json(data),
InterpreterType::int64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint32Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint32(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint32(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64(data) => HttpResponse::Ok().json(data),
InterpreterType::uint64Instance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manyuint64(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionaluint64(data) => HttpResponse::Ok().json(data),
InterpreterType::bool(data) => HttpResponse::Ok().json(data),
InterpreterType::boolInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybool(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbool(data) => HttpResponse::Ok().json(data),
InterpreterType::string(data) => HttpResponse::Ok().json(data),
InterpreterType::stringInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manystring(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalstring(data) => HttpResponse::Ok().json(data),
InterpreterType::bytes(data) => HttpResponse::Ok().json(data),
InterpreterType::bytesInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manybytes(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalbytes(data) => HttpResponse::Ok().json(data),
InterpreterType::simple(data) => HttpResponse::Ok().json(data),
InterpreterType::simpleInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manysimple(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalsimple(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapperInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::Manywrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::Optionalwrapper(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreQueryResult(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::wrapStoreRefInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManywrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalwrapStoreRef(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore_innardInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore_innard(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::querySpec_wrapStoreInstance(data) => HttpResponse::Ok().json(data),
InterpreterType::ManyquerySpec_wrapStore(data) => HttpResponse::Ok().json(data),
InterpreterType::OptionalquerySpec_wrapStore(data) => HttpResponse::Ok().json(data)
        };
    }
    
                            // FUNCTIONS
                            
        
        async fn insert(data: web::Data<AppData>, input: web::Json<wrapper>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
        let innerInput = input.into_inner();
        state.push(InterpreterType::wrapper(&innerInput));
        
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.insert_executable).await;
        }
        


        
        async fn get(data: web::Data<AppData>) -> impl Responder {
            let mut state: Vec<InterpreterType> = Vec::with_capacity(0);
            
            return conduit_byte_code_interpreter(&data.client, &mut state, &data.get_executable).await;
        }
        
                    
                            //ADDITIONAL
                            
                        #[derive(Serialize, Deserialize, Clone)]
                        enum simpleField {
                            simpledataFieldRef
                        }
                        

                        #[derive(Serialize, Deserialize, Clone)]
                        enum wrapperField {
                            wrapperinnardFieldRef
                        }
                        
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        .route(\\"/insert\\", web::post().to(insert))
.route(\\"/get\\", web::get().to(get))
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                    insert_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"echoVariable\\",
    \\"data\\": 0
  },
  {
    \\"kind\\": \\"storeInsertPreviouswrapStore\\"
  }
]\\"#####).unwrap(),
get_executable: serde_json::from_str(r#####\\"[
  {
    \\"kind\\": \\"storeQuerywrapStore\\"
  },
  {
    \\"kind\\": \\"returnPrevious\\"
  }
]\\"#####).unwrap()
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`struct containing struct: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	boolean NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        innard_ptr	INT,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
FOREIGN KEY(innard_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;
