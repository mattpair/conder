// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inserting struct containing struct array: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                
                
                            struct AppData {
                                client: Client
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
    #[derive(Serialize, Deserialize, Clone)]
    struct simple {
        data: String,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct wrapper {
        innard: Vec<simple>,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore_innard;
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore {
        innard: querySpec_wrapStore_innard
    }
    
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple6 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select right_ptr from rel_wrapStore_wrapper_and_simple)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple6.len());

    while let Some(row5) = allsimple6.pop() {
        let simpleEntityId7 = row5.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row5.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId7)
        })
    }

    

                let mut entityIdTosimple4: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                while let Some(row8) = allsimple3.pop() {
                    entityIdTosimple4.insert(row8.conduit_entity_id.unwrap(), row8);
                }
                

                let mut lr9 = client.query(\\"select left_ptr, right_ptr from rel_wrapStore_wrapper_and_simple\\", &[]).await?;
                let mut lrmap10: HashMap<i32, Vec<i32>> = HashMap::new();
                while let Some(lrrow11) = lr9.pop() {
                    let l12 = lrrow11.get(\\"left_ptr\\");
                    lrmap10.entry(l12)
                        .and_modify(|e13| { e13.push(lrrow11.get(\\"right_ptr\\")) })
                        .or_insert(vec![lrrow11.get(\\"right_ptr\\")]);
                }

                

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                // Extracting simples
                let empty17 = Vec::with_capacity(0);
                let entriessimple14 = match lrmap10.get(&wrapperEntityId2) {
                    Some(ptrs) => ptrs,
                    None => &empty17
                };

                let mut instancessimple15: Vec<simple> = Vec::with_capacity(entriessimple14.len());

                for child16 in entriessimple14 {
                    match entityIdTosimple4.get(&child16) {
                        Some(real) => instancessimple15.push(real.clone()),
                        None => panic!(\\"could not find expected simple\\")
                    };
                }
                
        out.push(wrapper {
            innard: instancessimple15,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Instr {
        
    Insert_wrapStore{insert_var_name: String}
Query_wrapStore{data: querySpec_wrapStore}
    
    }

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum AnyType {
        None,
Err(String),
simpleInstance(simple),
wrapperInstance(wrapper),
querySpec_wrapStore_innardInstance(querySpec_wrapStore_innard),
querySpec_wrapStoreInstance(querySpec_wrapStore),
QueryResultwrapStore(Vec<wrapper>)
    }

    // ControlFlow Interpreter:
    enum CF {
        Return(string),
        ReturnPrevious
    }


    enum CONDUIT_BYTE_CODE {
        ControlFlow(CF),
        Instruction(Instr)
    }

    async fn conduit_byte_code_interpreter(client: &Client, state: mut &HashMap<String, AnyType>, ops: Vec<CONDUIT_BYTE_CODE>) -> impl Responder {
        let mut prev: AnyType= AnyType::None;
        while let Some(o) = ops.pop() {
            match o {
                ControlFlow(c) => {
                    match c {
                        ReturnPrevious => {
                            return HttpResponse::Ok().json(prev);
                        },

                        Return(s) => state.get(&s) {
                            Some(data) => {
                                return HttpResponse::Ok().json(out);
                            },
                            None => panic!(\\"attempting to return a value that doesn't exist\\")
                        }
                    };
                },
                Instruction(i) => {
                    prev = match i {
                        
                Instr::Insert_wrapStore{insert_var_name} => {
                    let to_insert = match state.get(insert_var_name).unwrap() {
                        wrapperInstance(r) => r,
                        _ => panic!(\\"invalid insertion type\\")
                    };

                    match insert_wrapStore(&client, to_insert).await {
                        Ok(()) => AnyType::None,
                        Err(err) => AnyType::Err(err.to_string())
                    };
                },

                Instr::Query_wrapStore(v) => {
                    match query_interpreter_wrapStore(v, &client).await {
                        Ok(out) => AnyType::QueryResultwrapStore(out),
                        Err(err) => AnyType::Err(err.to_string())
                    };
                }
                    };

                    if let Err(e) = prev {
                        println!(\\"Error: {}\\", e);
                        return HttpResponse::BadRequest().finish();
                    }
                }
            };
        }
        return HttpResponse::Ok().json(AnyType::None);

    }

    
                            // FUNCTIONS
                            
                    
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`inserting struct containing struct array: main files 2`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                
                
                            struct AppData {
                                client: Client
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
    #[derive(Serialize, Deserialize, Clone)]
    struct simple {
        data: String,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct wrapper {
        innard: Vec<simple>,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore_innard;
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore {
        innard: querySpec_wrapStore_innard
    }
    
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple6 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select right_ptr from rel_wrapStore_wrapper_and_simple)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple6.len());

    while let Some(row5) = allsimple6.pop() {
        let simpleEntityId7 = row5.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row5.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId7)
        })
    }

    

                let mut entityIdTosimple4: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                while let Some(row8) = allsimple3.pop() {
                    entityIdTosimple4.insert(row8.conduit_entity_id.unwrap(), row8);
                }
                

                let mut lr9 = client.query(\\"select left_ptr, right_ptr from rel_wrapStore_wrapper_and_simple\\", &[]).await?;
                let mut lrmap10: HashMap<i32, Vec<i32>> = HashMap::new();
                while let Some(lrrow11) = lr9.pop() {
                    let l12 = lrrow11.get(\\"left_ptr\\");
                    lrmap10.entry(l12)
                        .and_modify(|e13| { e13.push(lrrow11.get(\\"right_ptr\\")) })
                        .or_insert(vec![lrrow11.get(\\"right_ptr\\")]);
                }

                

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                // Extracting simples
                let empty17 = Vec::with_capacity(0);
                let entriessimple14 = match lrmap10.get(&wrapperEntityId2) {
                    Some(ptrs) => ptrs,
                    None => &empty17
                };

                let mut instancessimple15: Vec<simple> = Vec::with_capacity(entriessimple14.len());

                for child16 in entriessimple14 {
                    match entityIdTosimple4.get(&child16) {
                        Some(real) => instancessimple15.push(real.clone()),
                        None => panic!(\\"could not find expected simple\\")
                    };
                }
                
        out.push(wrapper {
            innard: instancessimple15,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Instr {
        
    Insert_wrapStore{insert_var_name: String}
Query_wrapStore{data: querySpec_wrapStore}
    
    }

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum AnyType {
        None,
Err(String),
simpleInstance(simple),
wrapperInstance(wrapper),
querySpec_wrapStore_innardInstance(querySpec_wrapStore_innard),
querySpec_wrapStoreInstance(querySpec_wrapStore),
QueryResultwrapStore(Vec<wrapper>)
    }

    // ControlFlow Interpreter:
    enum CF {
        Return(string),
        ReturnPrevious
    }


    enum CONDUIT_BYTE_CODE {
        ControlFlow(CF),
        Instruction(Instr)
    }

    async fn conduit_byte_code_interpreter(client: &Client, state: mut &HashMap<String, AnyType>, ops: Vec<CONDUIT_BYTE_CODE>) -> impl Responder {
        let mut prev: AnyType= AnyType::None;
        while let Some(o) = ops.pop() {
            match o {
                ControlFlow(c) => {
                    match c {
                        ReturnPrevious => {
                            return HttpResponse::Ok().json(prev);
                        },

                        Return(s) => state.get(&s) {
                            Some(data) => {
                                return HttpResponse::Ok().json(out);
                            },
                            None => panic!(\\"attempting to return a value that doesn't exist\\")
                        }
                    };
                },
                Instruction(i) => {
                    prev = match i {
                        
                Instr::Insert_wrapStore{insert_var_name} => {
                    let to_insert = match state.get(insert_var_name).unwrap() {
                        wrapperInstance(r) => r,
                        _ => panic!(\\"invalid insertion type\\")
                    };

                    match insert_wrapStore(&client, to_insert).await {
                        Ok(()) => AnyType::None,
                        Err(err) => AnyType::Err(err.to_string())
                    };
                },

                Instr::Query_wrapStore(v) => {
                    match query_interpreter_wrapStore(v, &client).await {
                        Ok(out) => AnyType::QueryResultwrapStore(out),
                        Err(err) => AnyType::Err(err.to_string())
                    };
                }
                    };

                    if let Err(e) = prev {
                        println!(\\"Error: {}\\", e);
                        return HttpResponse::BadRequest().finish();
                    }
                }
            };
        }
        return HttpResponse::Ok().json(AnyType::None);

    }

    
                            // FUNCTIONS
                            
                    
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`inserting struct containing struct array: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                CREATE TABLE rel_wrapStore_wrapper_and_simple (
                    left_ptr INT,
                    right_ptr INT,
                    FOREIGN KEY(right_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
                    FOREIGN KEY(left_ptr) REFERENCES wrapStore(conduit_entity_id)
                );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`inserting struct containing struct array: postgres files 2`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                CREATE TABLE rel_wrapStore_wrapper_and_simple (
                    left_ptr INT,
                    right_ptr INT,
                    FOREIGN KEY(right_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
                    FOREIGN KEY(left_ptr) REFERENCES wrapStore(conduit_entity_id)
                );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`simple struct: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                
                
                            struct AppData {
                                client: Client
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
    #[derive(Serialize, Deserialize, Clone)]
    struct simple {
        data: f64,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_simpleStore;
    
                            // INTERPRETERS
                            
    async fn query_interpreter_simpleStore(querySpec: querySpec_simpleStore, client: &Client) -> Result<Vec<simple>, Error> {
        
    // Gettting all simple
    let mut allsimple1 = client.query(\\"select * from simpleStore \\", &[]).await?;

    

    let mut out = Vec::with_capacity(allsimple1.len());

    while let Some(row0) = allsimple1.pop() {
        let simpleEntityId2 = row0.get(\\"conduit_entity_id\\");
        
        out.push(simple {
            data: row0.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId2)
        })
    }

    
        return Ok(out);
    }
    
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Instr {
        
    Insert_simpleStore{insert_var_name: String}
Query_simpleStore{data: querySpec_simpleStore}
    
    }

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum AnyType {
        None,
Err(String),
simpleInstance(simple),
querySpec_simpleStoreInstance(querySpec_simpleStore),
QueryResultsimpleStore(Vec<simple>)
    }

    // ControlFlow Interpreter:
    enum CF {
        Return(string),
        ReturnPrevious
    }


    enum CONDUIT_BYTE_CODE {
        ControlFlow(CF),
        Instruction(Instr)
    }

    async fn conduit_byte_code_interpreter(client: &Client, state: mut &HashMap<String, AnyType>, ops: Vec<CONDUIT_BYTE_CODE>) -> impl Responder {
        let mut prev: AnyType= AnyType::None;
        while let Some(o) = ops.pop() {
            match o {
                ControlFlow(c) => {
                    match c {
                        ReturnPrevious => {
                            return HttpResponse::Ok().json(prev);
                        },

                        Return(s) => state.get(&s) {
                            Some(data) => {
                                return HttpResponse::Ok().json(out);
                            },
                            None => panic!(\\"attempting to return a value that doesn't exist\\")
                        }
                    };
                },
                Instruction(i) => {
                    prev = match i {
                        
                Instr::Insert_simpleStore{insert_var_name} => {
                    let to_insert = match state.get(insert_var_name).unwrap() {
                        simpleInstance(r) => r,
                        _ => panic!(\\"invalid insertion type\\")
                    };

                    match insert_simpleStore(&client, to_insert).await {
                        Ok(()) => AnyType::None,
                        Err(err) => AnyType::Err(err.to_string())
                    };
                },

                Instr::Query_simpleStore(v) => {
                    match query_interpreter_simpleStore(v, &client).await {
                        Ok(out) => AnyType::QueryResultsimpleStore(out),
                        Err(err) => AnyType::Err(err.to_string())
                    };
                }
                    };

                    if let Err(e) = prev {
                        println!(\\"Error: {}\\", e);
                        return HttpResponse::BadRequest().finish();
                    }
                }
            };
        }
        return HttpResponse::Ok().json(AnyType::None);

    }

    
                            // FUNCTIONS
                            
                    
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`simple struct: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE simpleStore (
        data	double precision NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`struct containing struct containing primitive array: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                
                
                            struct AppData {
                                client: Client
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
    #[derive(Serialize, Deserialize, Clone)]
    struct simple {
        data: Vec<String>,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct wrapper {
        innard: simple,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore_innard;
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore {
        innard: querySpec_wrapStore_innard
    }
    
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple5 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select innard_ptr from wrapStore)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple5.len());

    while let Some(row4) = allsimple5.pop() {
        let simpleEntityId6 = row4.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row4.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId6)
        })
    }

    

                    let mut entityIdTosimple7: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                    while let Some(row8) = allsimple3.pop() {
                        entityIdTosimple7.insert(row8.conduit_entity_id.unwrap(), row8);
                    }
                    

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                    // Extracting simple
                    let extractedsimple9 = match entityIdTosimple7.get(&row0.get(\\"innard_ptr\\")) {
                        Some(t) => t,
                        None => panic!(\\"did not get an expected innard_ptr\\")
                    };
                    
        out.push(wrapper {
            innard: extractedsimple9,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Instr {
        
    Insert_wrapStore{insert_var_name: String}
Query_wrapStore{data: querySpec_wrapStore}
    
    }

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum AnyType {
        None,
Err(String),
simpleInstance(simple),
wrapperInstance(wrapper),
querySpec_wrapStore_innardInstance(querySpec_wrapStore_innard),
querySpec_wrapStoreInstance(querySpec_wrapStore),
QueryResultwrapStore(Vec<wrapper>)
    }

    // ControlFlow Interpreter:
    enum CF {
        Return(string),
        ReturnPrevious
    }


    enum CONDUIT_BYTE_CODE {
        ControlFlow(CF),
        Instruction(Instr)
    }

    async fn conduit_byte_code_interpreter(client: &Client, state: mut &HashMap<String, AnyType>, ops: Vec<CONDUIT_BYTE_CODE>) -> impl Responder {
        let mut prev: AnyType= AnyType::None;
        while let Some(o) = ops.pop() {
            match o {
                ControlFlow(c) => {
                    match c {
                        ReturnPrevious => {
                            return HttpResponse::Ok().json(prev);
                        },

                        Return(s) => state.get(&s) {
                            Some(data) => {
                                return HttpResponse::Ok().json(out);
                            },
                            None => panic!(\\"attempting to return a value that doesn't exist\\")
                        }
                    };
                },
                Instruction(i) => {
                    prev = match i {
                        
                Instr::Insert_wrapStore{insert_var_name} => {
                    let to_insert = match state.get(insert_var_name).unwrap() {
                        wrapperInstance(r) => r,
                        _ => panic!(\\"invalid insertion type\\")
                    };

                    match insert_wrapStore(&client, to_insert).await {
                        Ok(()) => AnyType::None,
                        Err(err) => AnyType::Err(err.to_string())
                    };
                },

                Instr::Query_wrapStore(v) => {
                    match query_interpreter_wrapStore(v, &client).await {
                        Ok(out) => AnyType::QueryResultwrapStore(out),
                        Err(err) => AnyType::Err(err.to_string())
                    };
                }
                    };

                    if let Err(e) = prev {
                        println!(\\"Error: {}\\", e);
                        return HttpResponse::BadRequest().finish();
                    }
                }
            };
        }
        return HttpResponse::Ok().json(AnyType::None);

    }

    
                            // FUNCTIONS
                            
                    
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`struct containing struct containing primitive array: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	text[],
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        innard_ptr	INT,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
FOREIGN KEY(innard_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;

exports[`struct containing struct: main files 1`] = `
Array [
  Object {
    "content": "
                            #![allow(non_snake_case)]
                            #![allow(non_camel_case_types)]
                            #![allow(redundant_semicolon)]
                            use tokio_postgres::{NoTls, Client};
                            use actix_web::{web, App, HttpResponse, HttpServer, Responder};
                            use std::env;
                            use serde::{Deserialize, Serialize};
                            use tokio_postgres::error::{Error};
                            use std::collections::HashMap;
                
                
                            struct AppData {
                                client: Client
                            }
                            
                            #[derive(Serialize, Deserialize)]
                            struct City {
                                name: String,
                                location: i32
                            }
                            
                            // STRUCTS
                            
    #[derive(Serialize, Deserialize, Clone)]
    struct simple {
        data: bool,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct wrapper {
        innard: simple,
conduit_entity_id: Option<i32>
    }
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore_innard;
    

    #[derive(Serialize, Deserialize, Clone)]
    struct querySpec_wrapStore {
        innard: querySpec_wrapStore_innard
    }
    
                            // INTERPRETERS
                            
    async fn query_interpreter_wrapStore(querySpec: querySpec_wrapStore, client: &Client) -> Result<Vec<wrapper>, Error> {
        
    // Gettting all wrapper
    let mut allwrapper1 = client.query(\\"select * from wrapStore \\", &[]).await?;

    
    // Gettting all simple
    let mut allsimple5 = client.query(\\"select * from wrapStore_innard WHERE conduit_entity_id in (select innard_ptr from wrapStore)\\", &[]).await?;

    

    let mut allsimple3 = Vec::with_capacity(allsimple5.len());

    while let Some(row4) = allsimple5.pop() {
        let simpleEntityId6 = row4.get(\\"conduit_entity_id\\");
        
        allsimple3.push(simple {
            data: row4.get(\\"data\\"),
            conduit_entity_id: Some(simpleEntityId6)
        })
    }

    

                    let mut entityIdTosimple7: HashMap<i32, simple> = HashMap::with_capacity(allsimple3.len());
                    while let Some(row8) = allsimple3.pop() {
                        entityIdTosimple7.insert(row8.conduit_entity_id.unwrap(), row8);
                    }
                    

    let mut out = Vec::with_capacity(allwrapper1.len());

    while let Some(row0) = allwrapper1.pop() {
        let wrapperEntityId2 = row0.get(\\"conduit_entity_id\\");
        
                    // Extracting simple
                    let extractedsimple9 = match entityIdTosimple7.get(&row0.get(\\"innard_ptr\\")) {
                        Some(t) => t,
                        None => panic!(\\"did not get an expected innard_ptr\\")
                    };
                    
        out.push(wrapper {
            innard: extractedsimple9,
            conduit_entity_id: Some(wrapperEntityId2)
        })
    }

    
        return Ok(out);
    }
    
                            // OP INTERPRETER
                            

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum Instr {
        
    Insert_wrapStore{insert_var_name: String}
Query_wrapStore{data: querySpec_wrapStore}
    
    }

    #[derive(Serialize, Deserialize, Clone)]
    #[serde(tag = \\"kind\\", content= \\"data\\")]
    enum AnyType {
        None,
Err(String),
simpleInstance(simple),
wrapperInstance(wrapper),
querySpec_wrapStore_innardInstance(querySpec_wrapStore_innard),
querySpec_wrapStoreInstance(querySpec_wrapStore),
QueryResultwrapStore(Vec<wrapper>)
    }

    // ControlFlow Interpreter:
    enum CF {
        Return(string),
        ReturnPrevious
    }


    enum CONDUIT_BYTE_CODE {
        ControlFlow(CF),
        Instruction(Instr)
    }

    async fn conduit_byte_code_interpreter(client: &Client, state: mut &HashMap<String, AnyType>, ops: Vec<CONDUIT_BYTE_CODE>) -> impl Responder {
        let mut prev: AnyType= AnyType::None;
        while let Some(o) = ops.pop() {
            match o {
                ControlFlow(c) => {
                    match c {
                        ReturnPrevious => {
                            return HttpResponse::Ok().json(prev);
                        },

                        Return(s) => state.get(&s) {
                            Some(data) => {
                                return HttpResponse::Ok().json(out);
                            },
                            None => panic!(\\"attempting to return a value that doesn't exist\\")
                        }
                    };
                },
                Instruction(i) => {
                    prev = match i {
                        
                Instr::Insert_wrapStore{insert_var_name} => {
                    let to_insert = match state.get(insert_var_name).unwrap() {
                        wrapperInstance(r) => r,
                        _ => panic!(\\"invalid insertion type\\")
                    };

                    match insert_wrapStore(&client, to_insert).await {
                        Ok(()) => AnyType::None,
                        Err(err) => AnyType::Err(err.to_string())
                    };
                },

                Instr::Query_wrapStore(v) => {
                    match query_interpreter_wrapStore(v, &client).await {
                        Ok(out) => AnyType::QueryResultwrapStore(out),
                        Err(err) => AnyType::Err(err.to_string())
                    };
                }
                    };

                    if let Err(e) = prev {
                        println!(\\"Error: {}\\", e);
                        return HttpResponse::BadRequest().finish();
                    }
                }
            };
        }
        return HttpResponse::Ok().json(AnyType::None);

    }

    
                            // FUNCTIONS
                            
                    
                            #[actix_rt::main]
                            async fn main() -> std::io::Result<()> {
                                HttpServer::new(|| {
                                    App::new()
                                        .data_factory(|| make_app_data())
                                        .route(\\"/\\", web::get().to(index))
                                        
                                })
                                .bind(\\"0.0.0.0:8080\\")?
                                .run()
                                .await
                            }
                    
                            async fn index(data: web::Data<AppData>) -> impl Responder {
                                let mut rows = match data.client.query(\\"select name, location from cities\\", &[]).await {
                                    Ok(rows) => rows,
                                    Err(err) => panic!(\\"didn't succeed: {}\\", err)
                                };
                            
                                let mut out = Vec::with_capacity(rows.len());
                            
                                while let Some(row) = rows.pop() {
                                    out.push(City {
                                        name: row.get(0),
                                        location: row.get(1)
                                    })
                                }
                                return HttpResponse::Ok().json(out);
                            }
                
                            async fn make_app_data() -> Result<AppData, ()> {
                                let host = match env::var(\\"POSTGRES_SERVICE_HOST\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres location: {}\\", e)
                                };
                                let pwd = match env::var(\\"POSTGRES_PASSWORD\\") {
                                    Ok(pgloc) => pgloc,
                                    Err(e) => panic!(\\"didn't receive postgres password: {}\\", e)
                                };
                            
                                let (client, connection) = match tokio_postgres::connect(&format!(\\"host={} user=postgres password={}\\", host, pwd), NoTls).await {
                                    Ok(out) => out,
                                    Err(e) => panic!(\\"couldn't create connection: {}\\", e)
                                };
                                
                                // The connection object performs the actual communication with the database,
                                // so spawn it off to run on its own.
                                actix_rt::spawn(async move {
                                    if let Err(e) = connection.await {
                                        eprintln!(\\"connection error: {}\\", e);
                                    }
                                });
                                
                                
                                return Ok(AppData {
                                    client: client,
                                });
                            }
                            
                        ",
    "name": ".deploy/main/src/main.rs",
  },
]
`;

exports[`struct containing struct: postgres files 1`] = `
Array [
  Object {
    "content": "

                        CREATE TABLE cities (
                            name            varchar(80),
                            location        int
                        );
                
                        
    CREATE TABLE wrapStore_innard (
        data	boolean NOT NULL,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
PRIMARY KEY(conduit_entity_id)
    );

    CREATE TABLE wrapStore (
        innard_ptr	INT,
conduit_entity_id	INT	GENERATED ALWAYS AS IDENTITY,
FOREIGN KEY(innard_ptr) REFERENCES wrapStore_innard(conduit_entity_id),
PRIMARY KEY(conduit_entity_id)
    );
                        
                        
                        insert into cities(name, location)
                        values ('detroit', 12)",
    "name": ".deploy/postgres/startup/init.sql",
  },
]
`;
